30Page
Machine instruction set 기계어 명령 집합이 운영체제별로 따로 있음.
CPU가 user 모드에서 사용할 수 없고, kernel mode에서 사용할 수 있는 명령이
Privileged instruction이라고 함.
Control Register (CR0 ~ CR4) > 커널모드에서만 사용가능 (메모리관련)
TLB도 메모리와 관련이 있다.

28 ~ 29Page
두개의 모드 (유저  , 커널 ) 을 운영체제에서 사용할 수 있는데
모드 체인지는 트랩과 인터럽트가 일어났을 때 할 수 있다.
인터럽트 : 예상치 못한 외부 (CPU 기준) 사건 (하드웨어 or 소프트웨어)
예) 하드디스크가 CPU에 메세지를 보내는 경우. CPU외 나머지 device들에서
CPU가 외부 사건을 맞이하면 하던 일을 멈추고 원인 파악을 위한 행동을 함.(무시하고 하던 일 할 수 있음)
트랩 : CPU 내부에서 일어나는 일. ( 소프트웨어)
> exception(비정상적인 것 a/b 하는데 b가 0인 경우 프로그램 중단, 안되는 일을 하려고 할때. ex)privileged
 system call(운영체제가 어플에게 제공하는 서비스 인터페이스)
exception handler도 커널에 있음. 그런 일이 발생하면 커널모드로 스위칭됨.

32 page
작은 박스들이 os에 있는 함수들.
커널 함수를 앱이 활용하는 것은 위험.
앱들이 사용할수 있는 함수들을 올려둔다. >> system call 함수들.
system call 함수를 통해서 커널함수를 호출할수도 있지만, 앱이 직접 커널함수를 호출할 수는 없다.

33page
앱이 호출할 수 있는 system call 함수들. tree 형태처럼 함수가 되어있음.
부모 process가 죽으면 자식들도 다 죽음.

34page
CPU에서 프로세스가 system call을 하면, user모드에서 커널모드로 바뀜.
CPU에서 프로세스를 실행하다가, 하면 안되는 일을 했을때, 에러가 발생하고 EXCEPTION이 발생,
커널모드로 바뀌어 EXCEPTION HANDLING 함.
하드웨어들이 인터럽트하면 커널모드로 바뀜. INTERRUPT HANDLING함.

35page
Hardware virualization virtual machine을 생성하는 과정.

37page
직육면체가 하드웨어 플랫폼. 쉽게말해 기계가 3대 있다는 것. 각각의 os를 가지고 있다.
작은 동그라미 > app
하나가 된 직육면체 > 하드웨어 플랫폼. 점선 직육면체 > 가상의 하드웨어
각 os들이 자기 app을 서비스함. 기계가 한대 뿐인데 3대인것 처럼. > hardware virtualization
guest os(user 모드) 아랫쪽은 커널 모드.
virtualization layer에서는 대부분 linux를 쓴다.(커널 모드를 사용하는 부분)

38page
가상화를 하는 이유 
서버 통합, 비용적 장점, 관리적 장점.

39page
클라우드는 고성능 엔진으로 1인당 가상화 엔진을 제공하는것.

40page
SaaS : 클라우드에 설치된 앱을 쓰는 것.
IaaS : 하드웨어만 빌려 쓰는 것. (storage cloud)
PaaS : 프로그램 개발 플랫폼.

커널 : 마우스라는 하드웨어로 커서를 옮기면 cpu로 interrpt 될 때 모드 변환하여 실행하게 만듦.
privileged는 하드웨어에서 결정이 된다.

chap 2.
process란? 
job :설치한 소프트웨어 실행/이미지 파일 (저장 되어있을 뿐 움직이진 않음)
process : 실행을 위해서 커널에 등록된 entity
kernel이 시스템 퍼포먼스를 위해서 실행되지는 않음.
page 3
job이 실행 되면 노란색 타원의 영역에, 커널에 등록됨. 자원을 써야하기 때문에
프로세스의 생성과 커널에 등록이 동시에 일어난다.
page 4
글로벌 데이터 = 존재해야 하는 데이터

page 5
PCB를 할당받은 entity PCB는 커널안에 가지고 있음.
능동적인 entity > 스스로 디스크 io, 메세지 발송들을 하려고 하는 entity

page 8
프로세스를 관리하기 위해서 각 프로세스에 데이터를 보관함.

page 10
PCB는 커널에서만 관리할수 있다.
context save area >> 추후에 설명

page 13
사각형이 컨트롤 시스템 영역. 바깥이 job
새로운 프로세스가 생성(created)되면 커널에 등록도 되는 상황. > 메모리 요구
준비 후(메모리와 코드가 들어옴) > CPU에서 running 
 할당된 시간이 끝나면 preemption 프로세스 하나에 주어지는 시간 <time quantum> 1ms
프로세스 처리중 system call 이 걸리면  하드디스크 기준 10ms가 걸린다. 그순간 처리되던 프로세스는 쫒겨남.
asleep상태로 보냄. 다시 ready 상태로 보냄.

메모리 할당 못받는 경우. => suspended로 간다. asleep 상태에서 메모리를 할당 못받을때( 메모리를 우선적으로 처리해서 할당 못받을때)
>> suspended blocked로 갔다가, 처리되면 suspended ready로 간다.

page 15
시스템 콜에 의해서 프로세스가 생성된다. 트리구조로 프로세스 생성 
